# 笔记

## 1. 客户端组件中导入的子组件默认不会自动成为客户端组件

- 客户端组件中导入的子组件默认不会自动成为客户端组件，但它们的渲染行为取决于具体使用方式。

- "use client" 的作用域

  - 文件顶部添加 "use client" 的组件才被明确定义为客户端组件。这个指令不会自动传递给导入的子组件。

- **服务端组件可以导入客户端组件**

  - 服务端组件可以导入客户端组件，但只能作为 JSX 标签使用（不能直接在服务端组件逻辑中调用客户端组件的函数或钩子）
  - 当服务端组件导入客户端组件时，客户端组件会在服务器端被渲染成静态 HTML，但浏览器最终会接收到完整的 HTML 和 JavaScript 包，并执行客户端组件的水合（hydration）过程。
  - 从服务端组件到客户端组件传递的数据需要可序列化。

- **客户端组件并不能导入服务端组件**

  - 因为会导致服务端组件特性实现，服务端组件存在关键信息，导致泄漏等
  - 使用 children 属性传递服务端组件

- **从服务端组件到客户端组件传递的数据需要可序列化**

  - 不难发现，**在服务端组件中使用 JSX 作为传递给客户端组件的 prop.children，JSX 会先进行服务端组件渲染，再发送到客户端组件中**
  - 这意味着服务端使用到的第三方库，并不会参与到客户端的 bundle
  - 所以在性能优化这块，鼓励**尽可能将客户端组件在组件树中下移**,利用服务端组件在服务器预先渲染好的特点，减少包的体积

+ ### 🌐 混合渲染策略

| **场景**                   | **是否允许** | **解决方案**                |
| :------------------------- | :----------- | :-------------------------- |
| 服务端组件导入客户端组件   | ✅ 允许      | 直接作为 JSX 标签使用       |
| 客户端组件导入服务端组件   | ❌ 禁止      | 通过 props.children 传递    |
| 服务端组件使用客户端钩子   | ❌ 禁止      | 将逻辑移至客户端组件        |
| 服务端组件传递数据给客户端 | ✅ 允许      | 通过 props 传递可序列化数据 |

## 2. 客户端组件如何使用服务端组件

- 客户端组件中，并不难直接导入服务端组件使用

- 可以通过在使用客户端组件的上一层，将服务端组件作为客户端组件的 children 使用。

## 3. 为什么服务端组件传递给客户端组件的数据必须序列化

- 根本原因：服务端与客户端的环境隔离（运行环境不同）

  - 服务端组件：在 Node.js 环境中执行
  - 客户端组件：在浏览器环境中执行
  - 两者之间没有共享内存空间

- 其他原因：

  - 一致性要求：确保服务端生成的 HTML 与客户端水合结果一致
  - 安全隔离：防止服务端敏感数据/方法泄露到客户端
  - 性能优化：JSON 序列化是高效的数据传输方式

+ ### 不可序列化数据的典型问题

| **数据类型**     | **问题**                     | **示例**                        |
| :--------------- | :--------------------------- | :------------------------------ |
| **函数**         | 无法被 JSON.stringify() 转换 | `() => console.log('test')`     |
| **类实例**       | 丢失原型链和方法             | `new Date()`, `new Map()`       |
| **循环引用对象** | JSON.stringify() 会抛出错误  | `let a={}; a.self=a`            |
| **Symbol**       | 序列化后变为 `{}`            | `Symbol('id')`                  |
| **自定义类**     | 反序列化后变成普通对象       | `class User { getName(){...} }` |
| **React 组件**   | 无法通过网络传输             | `<MyComponent />`               |

## 4. Suspense 使用

+ 当你请求一个带有Suspense的组件页面，可以观察到一开始显示时间为毫秒级别，首页完成了显示，但是内容不全
+ 查看请求头，发现其 `Transfer-Encoding` 标头的值为 `chunked`，表示数据将以一系列分块的形式进行发送。HTML 首先收到骨架图的 HTML 进行渲染，再收到渲染完成的笔记列表 HTML 进行渲染
+ 随后查看网络时间，变成了秒级，而且加载的HTML，也发生了变化
+ Suspense 的效果就是允许你推迟渲染某些内容，直到满足某些条件（例如数据加载完毕）

## 5. RSC Payload

+ 当你点击页面的时候，请求RSC，可以看到标签显示的是`?rsc=xxxx`其实就暗示了它跟 RSC 相关,返回的是一种React自定义的特殊格式
+ SC Payload 包含信息：

  1.  服务端组件的渲染结果
  2.  客户端组件的占位位置和引用文件
  3.  从服务端组件传给客户端组件的数据
+ **使用这种格式的优势在于它针对流做了优化，数据是分行的，它们可以以流的形式逐行从服务端发送给客户端，客户端可以逐行解析 RSC Payload，渐进式渲染页面。**
+ SSR 和 RSC 的最大区别，其实现的关键就在于服务端组件没有被渲染成 HTML，而是一种特殊的格式（RSC Payload）
  +  SSR 和 RSC 是互补关系，是可以一起使用的，Next.js 中两者就是一起使用的。
  + RSC 的代码不会发送到客户端，但传统 SSR 所有组件的代码都会被发送到客户端
  + RSC 可以在组件树中任意位置获取后端，传统 SSR 只能在顶层（getServerSideProps）访问后端
  + 服务器组件可以重新获取，而不会丢失其树内的客户端状态

## 6. 缓存失效问题

路由缓存存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间：

*   **Session，缓存在导航期间会持续存在，当页面刷新的时候会被清除**
*   **自动失效期：单个路由段会在特定时长后自动失效，如果路由是静态渲染，持续 5 分钟，如果是动态渲染，持续 30s**
    + **静态路由**：默认 5 分钟
    + **动态路由**：默认 30 秒
    + 自定义配置：通过 `next.config.js` 调整

# 问题

- redis 使用
