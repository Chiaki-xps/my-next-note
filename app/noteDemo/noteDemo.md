# 笔记

## 客户端组件中导入的子组件默认不会自动成为客户端组件

- 客户端组件中导入的子组件默认不会自动成为客户端组件，但它们的渲染行为取决于具体使用方式。

- "use client" 的作用域

  - 文件顶部添加 "use client" 的组件才被明确定义为客户端组件。这个指令不会自动传递给导入的子组件。

- **服务端组件可以导入客户端组件**

  - 服务端组件可以导入客户端组件，但只能作为 JSX 标签使用（不能直接在服务端组件逻辑中调用客户端组件的函数或钩子）
  - 当服务端组件导入客户端组件时，客户端组件会在服务器端被渲染成静态 HTML，但浏览器最终会接收到完整的 HTML 和 JavaScript 包，并执行客户端组件的水合（hydration）过程。
  - 从服务端组件到客户端组件传递的数据需要可序列化。

- **客户端组件并不能导入服务端组件**

  - 因为会导致服务端组件特性实现，服务端组件存在关键信息，导致泄漏等
  - 使用 children 属性传递服务端组件

- **从服务端组件到客户端组件传递的数据需要可序列化**

  - 不难发现，**在服务端组件中使用 JSX 作为传递给客户端组件的 prop.children，JSX 会先进行服务端组件渲染，再发送到客户端组件中**
  - 这意味着服务端使用到的第三方库，并不会参与到客户端的 bundle
  - 所以在性能优化这块，鼓励**尽可能将客户端组件在组件树中下移**,利用服务端组件在服务器预先渲染好的特点，减少包的体积

### 🌐 混合渲染策略

| **场景**                   | **是否允许** | **解决方案**                |
| :------------------------- | :----------- | :-------------------------- |
| 服务端组件导入客户端组件   | ✅ 允许      | 直接作为 JSX 标签使用       |
| 客户端组件导入服务端组件   | ❌ 禁止      | 通过 props.children 传递    |
| 服务端组件使用客户端钩子   | ❌ 禁止      | 将逻辑移至客户端组件        |
| 服务端组件传递数据给客户端 | ✅ 允许      | 通过 props 传递可序列化数据 |

## 客户端组件如何使用服务端组件

- 客户端组件中，并不难直接导入服务端组件使用

- 可以通过在使用客户端组件的上一层，将服务端组件作为客户端组件的 children 使用。

## 为什么服务端组件传递给客户端组件的数据必须序列化

- 根本原因：服务端与客户端的环境隔离（运行环境不同）

  - 服务端组件：在 Node.js 环境中执行
  - 客户端组件：在浏览器环境中执行
  - 两者之间没有共享内存空间

- 其他原因：

  - 一致性要求：确保服务端生成的 HTML 与客户端水合结果一致
  - 安全隔离：防止服务端敏感数据/方法泄露到客户端
  - 性能优化：JSON 序列化是高效的数据传输方式

### 不可序列化数据的典型问题

| **数据类型**     | **问题**                     | **示例**                        |
| :--------------- | :--------------------------- | :------------------------------ |
| **函数**         | 无法被 JSON.stringify() 转换 | `() => console.log('test')`     |
| **类实例**       | 丢失原型链和方法             | `new Date()`, `new Map()`       |
| **循环引用对象** | JSON.stringify() 会抛出错误  | `let a={}; a.self=a`            |
| **Symbol**       | 序列化后变为 `{}`            | `Symbol('id')`                  |
| **自定义类**     | 反序列化后变成普通对象       | `class User { getName(){...} }` |
| **React 组件**   | 无法通过网络传输             | `<MyComponent />`               |

# 问题

- redis 使用
