Next.js 中有四种缓存机制：

| 机制                             | 缓存内容            | 存储地方 | 目的                      | 期间               |
| -------------------------------- | ------------------- | -------- | ------------------------- | ------------------ |
| 请求记忆（Request Memoization）  | 函数返回值          | 服务端   | 在 React 组件树中复用数据 | 每个请求的生命周期 |
| 数据缓存（Data Cache ）          | 数据                | 服务端   | 跨用户请求和部署复用数据  | 持久（可重新验证） |
| 完整路由缓存（Full Route Cache） | HTML 和 RSC payload | 服务端   | 降低渲染成本、提高性能    | 持久（可重新验证） |
| 路由缓存（Router Cache）         | RSC payload         | 客户端   | 减少导航时的服务端请求    | 用户会话或基于时间 |

默认情况下，Next.js 会尽可能多的使用缓存以提高性能和降低成本。像路由默认会采用静态渲染，数据请求的结果默认会被缓存。

## 1. 请求记忆（Request Memoization）

### 1.1. 工作原理

React 拓展了 [fetch API](https://nextjs.org/docs/app/building-your-application/caching#fetch)，当有相同的 URL 和参数的时候，React 会自动将请求结果缓存。

也就是说，即时你在组件树中的多个位置请求一份相同的数据，但数据获取只会执行一次。

同时发出一次相同请求，只会执行一次，后续返回的都是缓存结果

```js
// app/page.js
async function getItem() {
  // 自动缓存结果
  const res = await fetch('https://.../item/1')
  return res.json()
}
 
// 函数调用两次，但只会执行一次请求
const item = await getItem() // cache MISS
 
const item = await getItem() // cache HIT
```

关于请求记忆，要注意：

*   请求记忆是 React 的特性，并非 Next.js 的特性。 React 和 Next.js 都做了请求缓存，React 的方案叫做“请求记忆”，Next.js 的方案叫做“数据缓存”，两者有很多不同
*   请求记忆只适合用于用 `GET` 方法的 `fetch` 请求
*   请求记忆只应用于 React 组件树，也就是说你在 `generateMetadata`、`generateStaticParams`、布局、页面和其他服务端组件中使用 fetch 会触发请求记忆，但是在路由处理程序中使用则不会触发，因为这就不在 React 组件树中了

### 1.2. 持续时间

缓存会持续在服务端请求的生命周期中，直到 React 组件树渲染完毕。它的存在是为了避免组件树渲染的时候多次请求同一数据造成的性能影响。

### 1.3. 重新验证

由于请求记忆只会在渲染期间使用，因此也无须重新验证。

### 1.4. 退出方式

这个行为是 React 的默认优化。不建议退出。

如果你不希望 fetch 请求被记忆，可以借助 [AbortController](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 这个 Web API，具体使用方式如下（虽然这个 API 本来的作用是用来中止请求）：

```javascript
const { signal } = new AbortController()
fetch(url, { signal })
```

### 1.5. React Cache

如果你不能使用 fetch 请求，但是又想实现记忆，可以借助 React 的 cache 函数：

```js
// utils/get-item.ts
import { cache } from 'react'
import db from '@/lib/db'
 
export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

## 2. 数据缓存（Data Cache）

### 2.1. 工作原理

Next.js 有自己的数据缓存方案，可以跨服务端请求和构建部署存储数据。之所以能够实现，是因为 Next.js 拓展了 fetch API，在 Next.js 中，每个请求都可以设置自己的缓存方式。

不过与 React 的请求记忆不同的是，请求记忆因为只用于组件树渲染的时候，所以不用考虑数据缓存更新的情况，但 Next.js 的数据缓存方案更为持久，则需要考虑这个问题。

默认情况下，使用 `fetch` 的数据请求都会被缓存，这个缓存是持久的，它不会自动被重置。你可以使用 `fetch` 的 `cache` 和 `next.revalidate` 选项来配置缓存行为

```js
fetch(`https://...`, { cache: 'force-cache' | 'no-store' })
```

```js
fetch(`https://...`, { next: { revalidate: 3600 } })
```

### 2.2. 持续时间

数据缓存在传入请求和部署中都保持不变，除非重新验证或者选择退出。

### 2.3. 重新验证

Next.js 提供了两种方式更新缓存：

一种是**基于时间的重新验证（Time-based revalidation）**，即经过一定时间并有新请求产生后重新验证数据，适用于不经常更改且新鲜度不那么重要的数据。

一种是**按需重新验证（On-demand revalidation）**，根据事件手动重新验证数据。按需重新验证又可以使用基于标签（tag-based）和基于路径（path-based）两种方法重新验证数据。适用于需要尽快展示最新数据的场景。

### 2.4. 退出方式

如果你想要退出数据缓存，有两种方式：

一种是将 `fetch` 的 `cache` 选项设置为 `no-store`，示例如下，每次调用的时候都会重新获取数据：

```javascript
fetch(`https://...`, { cache: 'no-store' })
```

一种是使用[路由段配置项](https://juejin.cn/book/7307859898316881957/section/7309079033223446554)，它会影响该路由段中的所有数据请求：

```javascript
export const dynamic = 'force-dynamic'
```

# 一些知识

## 1. 什么是React Cache

React 18 新增的一个实验性方法

```js
import { cache } from 'react';

// 1. 创建缓存函数
const fetchUser = cache(async (id) => {
  const res = await fetch(`https://api.example.com/users/${id}`);
  return res.json();
});

// 2. 在组件中使用
export default async function UserProfile({ id }) {
  const user = await fetchUser(id); // 相同id只请求一次
  return <div>{user.name}</div>;
}
```

