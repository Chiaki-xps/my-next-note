## 1. CSR、SSR、SSG、ISR ?

- CSR（Client-side Rendering）客户端渲染
- SSR（Server-side Rendering）服务端渲染
- SSG（Static Site Generation）静态站点生成
- ISR（Incremental Static Regeneration）增量静态再生

## 2. Next 实现 CSR？

1. 使用 useEffect

- 使用 useEffect 请求数据
- 需要标记这是一个客户端页面 通过`"use client";`

2. swr

- 标记 `"use client";`
- 使用 swr

## 3. Next 实现 SSR

- （了解）Page Router 使用 SSR，你需要导出一个名为 `getServerSideProps`的 async 函数。这个函数会在每次请求的时候被调用。返回的数据会通过组件的 props 属性传递给组件。（现在已经不提倡使用 Page Router，也不再建议使用 `getServerSideProps`）

+ 在nextJS中，默认请求回构建一个静态生成页面，在这个过程中没有使用到异步数据或者动态函数的时候，这时候的渲染方式更接近于SSG（静态站生成）
+ App router 方式中，可以使用异步组件 + fetch选项（需要显式设置 cache: 'no-store'）

#### ssr 和 动态渲染

1. **SSR 是服务器端渲染技术**：在服务器生成完整 HTML
   + **SSR（Server-Side Rendering，服务器端渲染）** 是一种网页渲染技术，核心特点是：**在服务器上生成完整的 HTML 页面，然后发送给浏览器**。
2. **动态渲染是 Next.js 的实现策略**：智能启用 SSR 的模式

## 4. NextJS 实现 SSG

+ 什么是SSG？
  + SSG 会在构建阶段，就将页面编译为静态的 HTML 文件

+ nextJS中当不需要获取数据时，默认使用的就是 SSG

## 5. NextJs 实现 ISR

+ NextJS 的核心功能，解决SSG，一旦生成不再改变的问题

1. **初始构建**：页面在构建时首次生成并作为静态页面部署

2. 

   请求时再生

   ：

   - 当页面过期（或首次请求）时，Next.js 会在后台重新生成页面
   - 立即返回已缓存的旧版本
   - 生成完成后更新缓存

3. **下次请求**：用户获得新生成的页面

+ 

## 4. 动态加载组件（Code Splitting）

- 通过 `dynamic` 函数延迟加载非关键组件，减少首屏 JavaScript 体积

```js
import dynamic from "next/dynamic";

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
  loading: () => <p>Loading...</p>,
  ssr: false,
});

export default function Home() {
  return <HeavyComponent />;
}
```

## 一些概念

## 关于禁用缓存

- **禁用浏览器缓存和中间缓存的本质就是通过设置 `Cache-Control: 'no-store'` HTTP 头来实现的**。这是 HTTP 缓存控制机制中最严格、最彻底的禁用缓存指令。

- #### Fetch API

```js
fetch("https://api.example.com/data", {
  cache: "no-store", // 强制忽略缓存
});
```

- #### Axios

```js
axios.get("https://api.example.com/data", {
  headers: {
    "Cache-Control": "no-store", // 设置请求头
  },
});
```

- #### XMLHttpRequest

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://api.example.com/data");
xhr.setRequestHeader("Cache-Control", "no-store"); // 关键请求头
xhr.send();
```

- #### Node.js

```js
app.use((req, res, next) => {
  res.setHeader("Cache-Control", "no-store"); // 禁用缓存
  next();
});
```

- #### Next.js

```js
export default function handler(req, res) {
  res.setHeader("Cache-Control", "no-store");
  res.status(200).json({ data: "最新数据" });
}
```

- **`no-store` 的含义**：

  - 字面意思是"不要存储"
  - 强制所有缓存（包括浏览器缓存和所有中间代理/CDN 缓存）**不得存储**请求或响应的任何部分
  - 每次请求都必须直接向源服务器获取完整响应

- **与其他缓存指令的区别**：

  | 指令        | 作用                 | 是否禁用缓存  |
  | :---------- | :------------------- | :------------ |
  | `no-store`  | 完全禁止任何缓存存储 | ✅ 完全禁用   |
  | `no-cache`  | 可缓存但必须验证     | ❌ 不完全禁用 |
  | `private`   | 仅允许浏览器缓存     | ❌ 不完全禁用 |
  | `max-age=0` | 立即过期             | ❌ 不完全禁用 |

- 之前面试问到的一个问题：
  - 协商缓存的返回是 **304 Not Modified 状态码**
  - 强制缓存的返回是 200

# 问题
